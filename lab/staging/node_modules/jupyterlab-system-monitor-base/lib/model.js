// Some parts of this code is adapted from:
// https://github.com/jupyterlab/jupyterlab/blob/22cbc926e59443c67a80fcd363bb2de653087910/packages/statusbar/src/defaults/memoryUsage.tsx
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { URLExt } from '@jupyterlab/coreutils';
import { ServerConnection } from '@jupyterlab/services';
import { Poll } from '@lumino/polling';
import { Signal } from '@lumino/signaling';
/**
 * Number of values to keep in memory.
 */
const N_BUFFER = 20;
/**
 * A namespace for ResourcUsage statics.
 */
export var ResourceUsage;
(function (ResourceUsage) {
    /**
     * A model for the resource usage items.
     */
    class Model {
        /**
         * Construct a new resource usage model.
         *
         * @param options The options for creating the model.
         */
        constructor(options) {
            this._memoryAvailable = false;
            this._cpuAvailable = false;
            this._currentMemory = 0;
            this._currentCpuPercent = 0;
            this._memoryLimit = null;
            this._units = 'B';
            this._changed = new Signal(this);
            this._values = [];
            for (let i = 0; i < N_BUFFER; i++) {
                this._values.push({ memoryPercent: 0, cpuPercent: 0 });
            }
            this._poll = new Poll({
                factory: () => Private.factory(),
                frequency: {
                    interval: options.refreshRate,
                    backoff: true,
                },
                name: 'jupyterlab-system-monitor:ResourceUsage#metrics',
            });
            this._poll.ticked.connect((poll) => {
                const { payload, phase } = poll.state;
                if (phase === 'resolved') {
                    this._updateMetricsValues(payload);
                    return;
                }
                if (phase === 'rejected') {
                    const oldMemoryAvailable = this._memoryAvailable;
                    const oldCpuAvailable = this._cpuAvailable;
                    this._memoryAvailable = false;
                    this._cpuAvailable = false;
                    this._currentMemory = 0;
                    this._memoryLimit = null;
                    this._units = 'B';
                    if (oldMemoryAvailable || oldCpuAvailable) {
                        this._changed.emit();
                    }
                    return;
                }
            });
        }
        /**
         * A promise that resolves after the next request.
         */
        async refresh() {
            await this._poll.refresh();
            await this._poll.tick;
        }
        /**
         * Whether the memory metric is available.
         */
        get memoryAvailable() {
            return this._memoryAvailable;
        }
        /**
         * Whether the cpu metric is available.
         */
        get cpuAvailable() {
            return this._cpuAvailable;
        }
        /**
         * The current memory usage.
         */
        get currentMemory() {
            return this._currentMemory;
        }
        /**
         * The current memory limit, or null if not specified.
         */
        get memoryLimit() {
            return this._memoryLimit;
        }
        /**
         * The units for memory usages and limits.
         */
        get units() {
            return this._units;
        }
        /**
         * The current cpu percent.
         */
        get currentCpuPercent() {
            return this._currentCpuPercent;
        }
        /**
         * A signal emitted when the resource usage model changes.
         */
        get changed() {
            return this._changed;
        }
        /**
         * Get a list of the last metric values.
         */
        get values() {
            return this._values;
        }
        /**
         * Dispose of the memory usage model.
         */
        dispose() {
            this._poll.dispose();
        }
        /**
         * Given the results of the metrics request, update model values.
         *
         * @param value The metric request result.
         */
        _updateMetricsValues(value) {
            if (value === null) {
                this._memoryAvailable = false;
                this._cpuAvailable = false;
                this._currentMemory = 0;
                this._memoryLimit = null;
                this._units = 'B';
                return;
            }
            const numBytes = value.rss;
            const memoryLimit = value.limits.memory ? value.limits.memory.rss : null;
            const [currentMemory, units] = Private.convertToLargestUnit(numBytes);
            this._memoryAvailable = numBytes !== undefined;
            this._currentMemory = currentMemory;
            this._units = units;
            this._memoryLimit = memoryLimit
                ? memoryLimit / Private.MEMORY_UNIT_LIMITS[units]
                : null;
            const memoryPercent = this.memoryLimit
                ? Math.min(this._currentMemory / this.memoryLimit, 1)
                : null;
            const cpuPercent = value.cpu_percent;
            this._cpuAvailable = cpuPercent !== undefined;
            this._currentCpuPercent = this._cpuAvailable
                ? Math.min(1, cpuPercent / 100)
                : 0;
            this._values.push({ memoryPercent, cpuPercent: this._currentCpuPercent });
            this._values.shift();
            this._changed.emit(void 0);
        }
    }
    ResourceUsage.Model = Model;
})(ResourceUsage || (ResourceUsage = {}));
/**
 * A namespace for module private statics.
 */
var Private;
(function (Private) {
    /**
     * The number of decimal places to use when rendering memory usage.
     */
    Private.DECIMAL_PLACES = 2;
    /**
     * The number of bytes in each memory unit.
     */
    Private.MEMORY_UNIT_LIMITS = {
        B: 1,
        KB: 1024,
        MB: 1048576,
        GB: 1073741824,
        TB: 1099511627776,
        PB: 1125899906842624,
    };
    /**
     * Given a number of bytes, convert to the most human-readable
     * format, (GB, TB, etc).
     *
     * @param numBytes The number of bytes.
     */
    Private.convertToLargestUnit = (numBytes) => {
        if (numBytes < Private.MEMORY_UNIT_LIMITS.KB) {
            return [numBytes, 'B'];
        }
        else if (Private.MEMORY_UNIT_LIMITS.KB === numBytes ||
            numBytes < Private.MEMORY_UNIT_LIMITS.MB) {
            return [numBytes / Private.MEMORY_UNIT_LIMITS.KB, 'KB'];
        }
        else if (Private.MEMORY_UNIT_LIMITS.MB === numBytes ||
            numBytes < Private.MEMORY_UNIT_LIMITS.GB) {
            return [numBytes / Private.MEMORY_UNIT_LIMITS.MB, 'MB'];
        }
        else if (Private.MEMORY_UNIT_LIMITS.GB === numBytes ||
            numBytes < Private.MEMORY_UNIT_LIMITS.TB) {
            return [numBytes / Private.MEMORY_UNIT_LIMITS.GB, 'GB'];
        }
        else if (Private.MEMORY_UNIT_LIMITS.TB === numBytes ||
            numBytes < Private.MEMORY_UNIT_LIMITS.PB) {
            return [numBytes / Private.MEMORY_UNIT_LIMITS.TB, 'TB'];
        }
        else {
            return [numBytes / Private.MEMORY_UNIT_LIMITS.PB, 'PB'];
        }
    };
    /**
     * Settings for making requests to the server.
     */
    const SERVER_CONNECTION_SETTINGS = ServerConnection.makeSettings();
    /**
     * The url endpoint for making requests to the server.
     */
    const METRIC_URL = URLExt.join(SERVER_CONNECTION_SETTINGS.baseUrl, 'metrics');
    /**
     * Make a request to the backend.
     */
    Private.factory = async () => {
        const request = ServerConnection.makeRequest(METRIC_URL, {}, SERVER_CONNECTION_SETTINGS);
        const response = await request;
        if (response.ok) {
            return await response.json();
        }
        return null;
    };
})(Private || (Private = {}));
